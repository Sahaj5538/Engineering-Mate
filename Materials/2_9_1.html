<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Introduction to Algorithms - Course Material</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f6f8;
            line-height: 1.7;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        ul {
            margin-left: 20px;
        }
        code, pre {
            background: #eef;
            padding: 10px;
            display: block;
            border-radius: 6px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

<h1>Introduction to Algorithms</h1>

<section>
    <h2>1. Definition of an Algorithm</h2>
    <p>
        An <strong>algorithm</strong> is a step-by-step finite sequence of well-defined instructions used to perform a task or solve a specific problem. 
        Algorithms serve as a blueprint for solving problems in computer science, mathematics, and everyday life.
    </p>
    <p><strong>Example:</strong> Algorithm to add two numbers:</p>
    <pre><code>Step 1: Start
Step 2: Take two numbers as input
Step 3: Add the two numbers
Step 4: Display the result
Step 5: End</code></pre>
</section>

<section>
    <h2>2. Properties of an Algorithm</h2>
    <p>An algorithm must possess the following properties:</p>
    <ul>
        <li><strong>Input:</strong> Should accept zero or more inputs.</li>
        <li><strong>Output:</strong> Must produce at least one output.</li>
        <li><strong>Definiteness:</strong> Each instruction must be clear and unambiguous.</li>
        <li><strong>Finiteness:</strong> Must terminate after a finite number of steps.</li>
        <li><strong>Effectiveness:</strong> Each operation must be basic enough to be performed exactly and within a finite time.</li>
    </ul>
</section>

<section>
    <h2>3. Performance Analysis</h2>

    <h3>3.1 Space Complexity</h3>
    <p>
        <strong>Space complexity</strong> refers to the amount of memory space required by an algorithm to execute, relative to the input size.
    </p>
    <p>It includes:</p>
    <ul>
        <li>Instruction Space</li>
        <li>Data Space (for variables, constants, arrays, etc.)</li>
        <li>Environment Space (for function calls and recursion)</li>
    </ul>
    <p><strong>Example:</strong> An algorithm requiring an array of size <code>n</code> has a space complexity of O(n).</p>

    <h3>3.2 Time Complexity</h3>
    <p>
        <strong>Time complexity</strong> refers to the amount of computational time that an algorithm takes to complete, relative to the size of the input.
    </p>
    <p>It is generally expressed in terms of Big O notation, such as:</p>
    <ul>
        <li>O(1) — Constant time</li>
        <li>O(log n) — Logarithmic time</li>
        <li>O(n) — Linear time</li>
        <li>O(n²) — Quadratic time</li>
    </ul>
    <p><strong>Example:</strong> A loop that iterates through an array of <code>n</code> elements has a time complexity of O(n).</p>
</section>

<section>
    <h2>4. Amortized Analysis</h2>
    <p>
        <strong>Amortized analysis</strong> is a method used to average the time required to perform a sequence of operations over all the operations performed. 
        It provides a more accurate analysis compared to worst-case time complexity for certain algorithms.
    </p>
    <p>Common techniques for amortized analysis:</p>
    <ul>
        <li><strong>Aggregate Method:</strong> Total cost for n operations divided by n.</li>
        <li><strong>Accounting Method:</strong> Assign different charges to operations.</li>
        <li><strong>Potential Method:</strong> Associate a "potential" with the data structure that can increase or decrease with operations.</li>
    </ul>
    <p><strong>Example:</strong> In dynamic arrays (like ArrayList in Java), most insertions take O(1) time, but occasionally an insertion takes O(n) time when the array is resized. However, the <em>amortized</em> time per insertion remains O(1).</p>
</section>

</body>
</html>
