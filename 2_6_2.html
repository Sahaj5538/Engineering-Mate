<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Concurrency and Deadlocks</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f4f4f9;
      margin: 20px;
      color: #333;
      line-height: 1.7;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    section {
      background: #ffffff;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    ul {
      margin-left: 20px;
    }
    .example {
      background: #eef7fa;
      padding: 10px;
      border-left: 4px solid #3498db;
      margin: 10px 0;
    }
  </style>
</head>
<body>

<h1>UNIT II: Concurrency and Deadlocks</h1>

<section>
  <h2>Concurrency: Process Synchronization</h2>

  <h3>Critical-Section Problem</h3>
  <p>Critical-section problem occurs when multiple processes share a common resource. We must ensure that:</p>
  <ul>
    <li>Mutual Exclusion: Only one process can be in its critical section at a time.</li>
    <li>Progress: No process should wait indefinitely to enter its critical section.</li>
    <li>Bounded Waiting: A limit must exist on the number of times other processes can enter before a waiting process gets its chance.</li>
  </ul>

  <h3>Peterson’s Solution</h3>
  <p>A classical software-based solution for the two-process critical-section problem:</p>
  <ul>
    <li>Uses two shared variables: a boolean array `flag[2]` and an integer `turn`.</li>
    <li>Each process sets its flag and gives priority to the other before entering the critical section.</li>
  </ul>

  <div class="example">
    <strong>Example:</strong><br>
    <code>
      flag[i] = true;<br>
      turn = j;<br>
      while (flag[j] && turn == j);<br>
      // critical section
    </code>
  </div>

  <h3>Synchronization Hardware</h3>
  <p>Hardware-based solutions using instructions like:</p>
  <ul>
    <li>Test and Set</li>
    <li>Compare and Swap</li>
    <li>Exchange</li>
  </ul>
  <p>These instructions are atomic and help implement locks and semaphores effectively.</p>

  <h3>Semaphores</h3>
  <p>Semaphores are synchronization tools that help manage concurrent processes:</p>
  <ul>
    <li><strong>Binary Semaphore:</strong> Only 0 or 1 (used like a lock).</li>
    <li><strong>Counting Semaphore:</strong> Allows resource sharing up to a given limit.</li>
  </ul>

  <h3>Classic Problems of Synchronization</h3>
  <ul>
    <li>Producer-Consumer Problem</li>
    <li>Readers-Writers Problem</li>
    <li>Dining Philosophers Problem</li>
  </ul>

  <h3>Monitors</h3>
  <p>High-level synchronization construct that encapsulates shared variables, operations, and synchronization within one module.</p>

  <div class="example">
    <strong>Example:</strong>  
    <em>Monitors allow only one process inside at a time — automatically handling mutual exclusion.</em>
  </div>

</section>

<section>
  <h2>Deadlocks</h2>

  <h3>Principles of Deadlock</h3>
  <p>Deadlock occurs when a group of processes are blocked, each waiting for another to release a resource.</p>

  <h3>System Model</h3>
  <p>Processes request and release resources dynamically.</p>

  <h3>Deadlock Characterization</h3>
  <p>Four necessary conditions for deadlock:</p>
  <ul>
    <li>Mutual Exclusion</li>
    <li>Hold and Wait</li>
    <li>No Preemption</li>
    <li>Circular Wait</li>
  </ul>

  <h3>Deadlock Prevention</h3>
  <p>Design the system in such a way that at least one of the necessary conditions cannot occur:</p>
  <ul>
    <li>Deny mutual exclusion (impractical)</li>
    <li>Prevent hold and wait</li>
    <li>Allow preemption</li>
    <li>Eliminate circular wait</li>
  </ul>

  <h3>Deadlock Detection and Recovery</h3>
  <p>Allow deadlocks to occur, but detect and recover:</p>
  <ul>
    <li>Resource Allocation Graph</li>
    <li>Detection algorithm for single instance resources</li>
    <li>Recovery through killing processes or preempting resources</li>
  </ul>

  <h3>Deadlock Avoidance</h3>
  <p>Proactively avoid deadlock by carefully resource allocation using algorithms like:</p>
  <ul>
    <li>Banker's Algorithm</li>
    <li>Safe and Unsafe States</li>
  </ul>

</section>

</body>
</html>
