<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Disjoint Sets and Divide and Conquer - Course Material</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f6f8;
            line-height: 1.7;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        section {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        ul {
            margin-left: 20px;
        }
        code, pre {
            background: #eef;
            padding: 10px;
            display: block;
            border-radius: 6px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

<h1>Disjoint Sets and Divide and Conquer</h1>

<section>
    <h2>1. Disjoint Sets</h2>
    <p>Disjoint sets are sets whose elements are completely separate from each other. Disjoint Set Data Structures are useful for grouping items into non-overlapping subsets.</p>

    <h3>1.1 Disjoint Set Representation</h3>
    <p>Disjoint sets can be represented using:</p>
    <ul>
        <li><strong>Array representation:</strong> Each element points to its parent.</li>
        <li><strong>Tree representation:</strong> Sets are represented as trees to allow faster merging.</li>
    </ul>

    <h3>1.2 Operations</h3>
    <ul>
        <li><strong>Find:</strong> Determines which subset a particular element belongs to.</li>
        <li><strong>Union:</strong> Merges two subsets into a single subset.</li>
    </ul>

    <h3>1.3 Union and Find Algorithms</h3>
    <p>Basic operations:</p>
    <pre><code>// Find operation (without path compression)
int find(int x) {
    if (parent[x] == x)
        return x;
    else
        return find(parent[x]);
}

// Union operation
void union(int x, int y) {
    int xRoot = find(x);
    int yRoot = find(y);
    parent[xRoot] = yRoot;
}</code></pre>
    <p>Optimizations:</p>
    <ul>
        <li><strong>Path Compression:</strong> Flatten the structure of the tree during find operations.</li>
        <li><strong>Union by Rank:</strong> Attach smaller depth tree under root of deeper tree.</li>
    </ul>
</section>

<section>
    <h2>2. Divide and Conquer</h2>
    <p><strong>Divide and Conquer</strong> is an algorithm design paradigm that works by recursively breaking down a problem into two or more sub-problems of the same type, until they become simple enough to be solved directly.</p>

    <h3>2.1 General Method</h3>
    <ul>
        <li><strong>Divide:</strong> Divide the problem into smaller sub-problems.</li>
        <li><strong>Conquer:</strong> Solve the sub-problems recursively.</li>
        <li><strong>Combine:</strong> Combine the solutions to sub-problems to form the final solution.</li>
    </ul>

    <h3>2.2 Applications</h3>
    <ul>
        <li>Binary Search</li>
        <li>Quick Sort</li>
        <li>Merge Sort</li>
        <li>Strassen's Matrix Multiplication</li>
    </ul>

    <h3>2.3 Binary Search</h3>
    <p>Binary search finds the position of a target value within a sorted array.</p>
    <pre><code>int binarySearch(int arr[], int left, int right, int x) {
    if (right >= left) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == x)
            return mid;
        
        if (arr[mid] > x)
            return binarySearch(arr, left, mid - 1, x);
        
        return binarySearch(arr, mid + 1, right, x);
    }
    return -1;
}</code></pre>

    <h3>2.4 Quick Sort</h3>
    <p>Quick sort is a divide-and-conquer algorithm that picks an element as a pivot and partitions the array around the pivot.</p>
    <pre><code>void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}</code></pre>

    <h3>2.5 Merge Sort</h3>
    <p>Merge sort divides the array into halves, sorts them and then merges the sorted halves.</p>
    <pre><code>void mergeSort(int arr[], int l, int r) {
    if (l &lt; r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}</code></pre>

    <h3>2.6 Strassen’s Matrix Multiplication</h3>
    <p>Strassen’s algorithm multiplies two matrices faster than the conventional algorithm by reducing the number of recursive multiplications.</p>
    <p>It divides matrices into submatrices and uses only 7 multiplications instead of 8.</p>
</section>

</body>
</html>
